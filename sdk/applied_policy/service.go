// Code generated by goa v2.0.0-wip, DO NOT EDIT.
//
// AppliedPolicy service
//
// Command:
// $ goa gen github.com/rightscale/governance/front_service/design

package appliedpolicy

import (
	"context"

	appliedpolicyviews "github.com/rightscale/right_pt/sdk/applied_policy/views"
	"goa.design/goa"
	"goa.design/goa/security"
)

// Service is the AppliedPolicy service interface.
type Service interface {
	// Create applies a policy template to a given project. The applied policy will
	// continually run until deleted.
	// The "view" return value must have one of the following views
	//	- "default"
	//	- "source"
	//	- "link"
	Create(context.Context, *CreatePayload) (res *AppliedPolicy, view string, err error)
	// Delete stops and deletes an applied policy.
	Delete(context.Context, *DeletePayload) (err error)
	// Show retrieves the details of an applied policy.
	// The "view" return value must have one of the following views
	//	- "default"
	//	- "source"
	//	- "link"
	Show(context.Context, *ShowPayload) (res *AppliedPolicy, view string, err error)
	// ShowStatus retrieves the evaluation status details of an applied policy.
	ShowStatus(context.Context, *ShowStatusPayload) (res *AppliedPolicyStatus, err error)
	// ShowLog retrieves the last evaluation log of an applied policy. *The content
	// type is "text/markdown"*.
	ShowLog(context.Context, *ShowLogPayload) (res *AppliedPolicyLog, err error)
	// Index retrieves the list of applied policies in a project.
	// The "view" return value must have one of the following views
	//	- "default"
	//	- "link"
	Index(context.Context, *IndexPayload) (res *AppliedPolicyList, view string, err error)
	// Evaluate executes an applied policy evaluation on demand. It does not affect
	// the normal execution schedule.
	Evaluate(context.Context, *EvaluatePayload) (err error)
}

// Auther defines the authorization functions to be implemented by the service.
type Auther interface {
	// JWTAuth implements the authorization logic for the JWT security scheme.
	JWTAuth(ctx context.Context, token string, schema *security.JWTScheme) (context.Context, error)
}

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "AppliedPolicy"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [7]string{"create", "delete", "show", "show_status", "show_log", "index", "evaluate"}

// CreatePayload is the payload type of the AppliedPolicy service create method.
type CreatePayload struct {
	// project_id identifies a project by ID.
	ProjectID uint
	// name provides a name for this specific application of the policy.
	Name string
	// description provides a human readable description for this specific
	// application of the policy.
	Description *string
	// template_href is the href of the policy template or published template that
	// is applied.
	TemplateHref string
	// frequency specifies the frequency with which to run policy evaluations
	Frequency string
	// dry_run is a flag used for testing a policy so that an incident can be
	// raised without performing an action.
	DryRun bool
	// options lists the configuration options used to parameterize the policy.
	Options []*ConfigurationOptionCreateType
	// JWT token used to perform authorization
	Token *string
	// API Version, must be specified using this header
	APIVersion string
}

// AppliedPolicy is the result type of the AppliedPolicy service create method.
type AppliedPolicy struct {
	// id identifies an applied policy by ID.
	ID string
	// name provides a name for this specific application of the policy.
	Name string
	// Project represents a RightScale project and provides some information about
	// the project.
	Project *Project
	// href is the href of the applied policy.
	Href string
	// policy_template links to key attributes of the policy template from which
	// the applied policy originated.
	PolicyTemplate *PolicyTemplate
	// published_template links to key attributes of the published template from
	// which the applied policy originated.
	PublishedTemplate *PublishedTemplate
	// description provides a human readable description for this specific
	// application of the policy.
	Description *string
	// doc_link is a HTTP URI to a page containing detailed documentation for the
	// policy.
	DocLink *string
	// info is an arbitrary set of key/value pairs that provide additional
	// information such as the policy author, support contact information, etc.
	Info map[string]string
	// created_by is the RightScale user that applied the policy.
	CreatedBy *User
	// created_at is the applied policy creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_at is the applied policy update timestamp in RFC3339 format.
	UpdatedAt *string
	// severity defines the severity level of incidents raised from this applied
	// policy.
	Severity *string
	// category is the type categorization of the applied policy.
	Category *string
	// frequency specifies the frequency with which to run policy evaluations
	Frequency *string
	// dry_run is a flag used for testing a policy so that an incident can be
	// raised without performing an action.
	DryRun *bool
	// options lists the configuration options used to parameterize the policy.
	Options []*ConfigurationOption
	// status is used to identify the current status of the applied policy.
	Status *string
	// error is the error message returned if the evaluation failed. On success
	// this attribute is empty.
	Error *string
	// errored_at is the applied policy error timestamp in RFC3339 format. On
	// success this attribute is empty.
	ErroredAt *string
	// kind is "gov#applied_policy".
	Kind string
}

// DeletePayload is the payload type of the AppliedPolicy service delete method.
type DeletePayload struct {
	// project_id identifies a project by ID.
	ProjectID uint
	// policy_id identifies an applied policy by ID.
	PolicyID string
	// JWT token used to perform authorization
	Token *string
	// API Version, must be specified using this header
	APIVersion string
}

// ShowPayload is the payload type of the AppliedPolicy service show method.
type ShowPayload struct {
	// project_id identifies a project by ID.
	ProjectID uint
	// policy_id identifies an applied policy by ID.
	PolicyID string
	// View used to render applied policy
	View *string
	// JWT token used to perform authorization
	Token *string
	// API Version, must be specified using this header
	APIVersion string
}

// ShowStatusPayload is the payload type of the AppliedPolicy service
// show_status method.
type ShowStatusPayload struct {
	// project_id identifies a project by ID.
	ProjectID uint
	// policy_id identifies an applied policy by ID.
	PolicyID string
	// JWT token used to perform authorization
	Token *string
	// API Version, must be specified using this header
	APIVersion string
}

// AppliedPolicyStatus is the result type of the AppliedPolicy service
// show_status method.
type AppliedPolicyStatus struct {
	// last_evaluation_start is the timestamp of the start of the last policy
	// evaluation.
	LastEvaluationStart *string
	// last_evaluation_finish is the timestamp of the finish of the last policy
	// evaluation. It is omitted if the policy is currently evaluating.
	LastEvaluationFinish *string
	// next_evaluation_start is the timestamp of the next expected policy
	// evaluation start. It is omitted if the policy is currently evalutating.
	NextEvaluationStart *string
	// evaluation_error is the error message returned if the evaluation failed. On
	// success this attribute is empty.
	EvaluationError *string
	// evaluation_errored_at is the timestamp of the last evaluation error.
	EvaluationErroredAt *string
}

// ShowLogPayload is the payload type of the AppliedPolicy service show_log
// method.
type ShowLogPayload struct {
	// project_id identifies a project by ID.
	ProjectID uint
	// policy_id identifies an applied policy by ID.
	PolicyID string
	// etag is an HTTP ETag. It is typically the previous ETag value retrieved by
	// client if any. Service returns an empty response with HTTP status code 304
	// Not Modified if value matches current value server side.
	Etag *string
	// JWT token used to perform authorization
	Token *string
	// API Version, must be specified using this header
	APIVersion string
}

// AppliedPolicyLog is the result type of the AppliedPolicy service show_log
// method.
type AppliedPolicyLog struct {
	// response_body is the log from the last policy evaluation, directly in the
	// body of the response. *The content type is "text/markdown"*.
	ResponseBody *string
	// last_evaluation_finish is the timestamp of the finish of the last policy
	// evaluation.
	LastModified *string
	// etag is an HTTP ETag for the applied policy list.
	Etag *string
}

// IndexPayload is the payload type of the AppliedPolicy service index method.
type IndexPayload struct {
	// project_id identifies a project by ID.
	ProjectID uint
	// etag is an HTTP ETag. It is typically the previous ETag value retrieved by
	// client if any. Service returns an empty response with HTTP status code 304
	// Not Modified if value matches current value server side.
	Etag *string
	// View used to render applied policies
	View *string
	// name is a filter to only show applied policies that match this name.
	Name []string
	// JWT token used to perform authorization
	Token *string
	// API Version, must be specified using this header
	APIVersion string
}

// AppliedPolicyList is the result type of the AppliedPolicy service index
// method.
type AppliedPolicyList struct {
	// count is the number of applied policies in the list.
	Count *uint
	// etag is an HTTP ETag for the applied policy list.
	Etag string
	// items is the array of applied policies.
	Items AppliedPolicyCollection
	// not_modified is a flag used internally that indicates how to encode the HTTP
	// response (i.e. 200 or 304).
	NotModified *string
	// kind is "gov#applied_policy_list".
	Kind string
}

// EvaluatePayload is the payload type of the AppliedPolicy service evaluate
// method.
type EvaluatePayload struct {
	// project_id identifies a project by ID.
	ProjectID uint
	// policy_id identifies an applied policy by ID.
	PolicyID string
	// JWT token used to perform authorization
	Token *string
	// API Version, must be specified using this header
	APIVersion string
}

// ConfigurationOptionCreateType is the payload for creating a single parameter
// value used to configure an applied policy.
type ConfigurationOptionCreateType struct {
	// name of option
	Name string
	// value of option
	Value interface{}
}

// Project represents a RightScale project and provides some information about
// the project.
type Project struct {
	// id is the Project ID
	ID uint
	// name is the Project Name
	Name string
	// org_id is the RightScale Organization ID
	OrgID uint
	// org_name is the RightScale Organization Name
	OrgName string
}

// PolicyTemplate describes a previously uploaded policy template.
type PolicyTemplate struct {
	// id identifies a policy template by ID.
	ID string
	// name is the unique name of the policy template in the project.
	Name string
	// project_id is the ID of the project that the policy template applies to.
	ProjectID *uint
	// rs_pt_ver is the policy engine version.
	RsPtVer *uint
	// short_description is the short description of the policy template.
	ShortDescription *string
	// long_description is the long description of the policy template. The content
	// can be markdown.
	LongDescription *string
	// doc_link is an HTTP URI to a page containing detailed documentation for the
	// policy.
	DocLink *string
	// info is an arbitrary set of key/value pairs that provide additional
	// information such as the policy author, support contact information, etc.
	Info map[string]string
	// href is the href of the policy template.
	Href string
	// filename is the name of the file that was uploaded to create the policy
	// template.
	Filename *string
	// source is the policy template source code.
	Source *string
	// fingerprint is a SHA created during compilation. It is used to determine if
	// the template is outdated.
	Fingerprint string
	// category is the type categorization of the policy template.
	Category *string
	// created_by is the RightScale user that created the policy template.
	CreatedBy *User
	// created_at is the policy template creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_by is the RightScale user that updated the policy template.
	UpdatedBy *User
	// updated_at is the last update timestamp in RFC3339 format.
	UpdatedAt *string
	// permissions is a list of permissions required to run the policy.
	Permissions map[string]*Permission
	// required_roles is a list of governance roles, derived from permissions,
	// required to run the policy.
	RequiredRoles []string
	// parameters is a list of parameters required to apply the policy.
	Parameters map[string]*Parameter
	// severity defines the severity level of incidents raised from this policy
	// template.
	Severity *string
	// kind is "gov#policy_template".
	Kind string
}

// User represents a registered RightScale user.
type User struct {
	// ID of user
	ID uint
	// email of user
	Email string
	// name of user, usually of the form 'First Last'
	Name string
}

// Permission defines a role required in RightScale to perform actions on
// resources
type Permission struct {
	// Name of a permission
	Name string `json:"name"`
	// Label is used in the UI
	Label *string `json:"label"`
	// List of resource names the permission is applied to
	Resources []string `json:"resources"`
	// List of action names the permission is applied to
	Actions []string `json:"actions"`
}

// Parameter defines a parameter given as input to a Policy
type Parameter struct {
	// Name of the parameter
	Name string `json:"name"`
	// Type of the parameter
	Type string `json:"type"`
	// Label to show in the UI
	Label string `json:"label"`
	// The index of this parameter in the list
	Index uint `json:"index"`
	// The category used to group parameters
	Category *string `json:"category"`
	// Description of the parameter
	Description *string `json:"description"`
	// The default value for the parameter
	Default interface{} `json:"default"`
	// no_echo determines whether the value of the parameter should be hidden in
	// UIs and API responses.
	NoEcho bool `json:"no_echo"`
	// List of values allowed for this parameter
	AllowedValues []interface{} `json:"allowed_values"`
	// The minimum length of a string parameter
	MinLength *uint `json:"min_length"`
	// The maximum length of a string parameter
	MaxLength *uint `json:"max_length"`
	// The minimum value of a number parmameter
	MinValue *float64 `json:"min_value"`
	// The maximum value of a number parameter
	MaxValue *float64 `json:"max_value"`
	// The regular expression pattern used to validate a string parameter
	AllowedPattern *Regexp `json:"allowed_pattern"`
	// The description used for constraints
	ConstraintDescription *string `json:"constraint_description"`
}

// Regular expression
type Regexp struct {
	// Pattern is the regular expression pattern.
	Pattern string `json:"pattern"`
	// Options are the regular expression options. Options i (case insensitve) and
	// m (match over newlines) supported.
	Options *string `json:"options"`
}

// PublishedTemplate describes a previously created published template.
type PublishedTemplate struct {
	// id identifies a published template by ID.
	ID string
	// name is the unique name of the published template in the organization.
	Name string
	// org_id is the ID of the organization that the published template belongs to.
	OrgID *uint
	// project_id is the ID of the project that the published template is published
	// from.
	ProjectID *uint
	// policy_template_id is the ID of the policy template from which the published
	// template originated.
	PolicyTemplateID *string
	// policy_template_url is the full URL to the policy template from which the
	// published template originated.
	PolicyTemplateURL *string
	// policy_template_fingerprint is fingerprint of the policy template. It is
	// used to determine if the policy template that this was published from is
	// outdated.
	PolicyTemplateFingerprint *string
	// rs_pt_ver is the policy engine version.
	RsPtVer *uint
	// short_description is the short description of the published template.
	ShortDescription *string
	// long_description is the long description of the published template. The
	// content can be markdown.
	LongDescription *string
	// doc_link is a HTTP URI to a page containing detailed documentation for the
	// policy.
	DocLink *string
	// info is an arbitrary set of key/value pairs that provide additional
	// information such as the policy author, support contact information, etc.
	Info map[string]string
	// href is the self-referential href of the published template.
	Href string
	// filename is the name of the file that was uploaded to create the policy
	// template.
	Filename *string
	// source is published template source code.
	Source *string
	// fingerprint is a SHA created during compilation. It is used to determine if
	// the policy template that this was published from is outdated.
	Fingerprint string
	// category is the type categorization of the published template.
	Category *string
	// created_by is the RightScale user that created the published template.
	CreatedBy *User
	// created_at is the published template creation timestamp in RFC3339 format.
	CreatedAt *string
	// updated_by is the RightScale user that updated the published template.
	UpdatedBy *User
	// updated_at is the published template update timestamp in RFC3339 format.
	UpdatedAt *string
	// permissions is a list of permissions required to run the policy.
	Permissions map[string]*Permission
	// required_roles is a list of governance roles, derived from permissions,
	// required to run the policy.
	RequiredRoles []string
	// parameters is a list of parameters required to apply the policy.
	Parameters map[string]*Parameter
	// severity defines the severity level of incidents raised from this published
	// template.
	Severity *string
	// built_in is a flag to indicate whether the published template is a
	// "built-in" RS-supplied template.
	BuiltIn *bool
	// hidden is a flag to indicate whether the published template is hidden.
	Hidden *bool
	// hidden_by is the RightScale user that marked the published template as
	// hidden.
	HiddenBy *User
	// hidden_at is the hidden at timestamp in RFC3339 format.
	HiddenAt *string
	// kind is "gov#published_template".
	Kind string
}

// ConfigurationOption describes a single parameter value used to configure an
// applied policy.
type ConfigurationOption struct {
	// name of option
	Name string
	// label of option
	Label string
	// type of option
	Type string
	// value of option
	Value interface{}
}

type AppliedPolicyCollection []*AppliedPolicy

// MakeUnauthorized builds a goa.ServiceError from an error.
func MakeUnauthorized(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "unauthorized",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeForbidden builds a goa.ServiceError from an error.
func MakeForbidden(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "forbidden",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeBadRequest builds a goa.ServiceError from an error.
func MakeBadRequest(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "bad_request",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeBadGateway builds a goa.ServiceError from an error.
func MakeBadGateway(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "bad_gateway",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeInternalError builds a goa.ServiceError from an error.
func MakeInternalError(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "internal_error",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeUnprocessableEntity builds a goa.ServiceError from an error.
func MakeUnprocessableEntity(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "unprocessable_entity",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeNotFound builds a goa.ServiceError from an error.
func MakeNotFound(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "not_found",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// NewAppliedPolicy initializes result type AppliedPolicy from viewed result
// type AppliedPolicy.
func NewAppliedPolicy(vres *appliedpolicyviews.AppliedPolicy) *AppliedPolicy {
	var res *AppliedPolicy
	switch vres.View {
	case "default", "":
		res = newAppliedPolicy(vres.Projected)
	case "source":
		res = newAppliedPolicySource(vres.Projected)
	case "link":
		res = newAppliedPolicyLink(vres.Projected)
	}
	return res
}

// NewViewedAppliedPolicy initializes viewed result type AppliedPolicy from
// result type AppliedPolicy using the given view.
func NewViewedAppliedPolicy(res *AppliedPolicy, view string) *appliedpolicyviews.AppliedPolicy {
	var vres *appliedpolicyviews.AppliedPolicy
	switch view {
	case "default", "":
		p := newAppliedPolicyView(res)
		vres = &appliedpolicyviews.AppliedPolicy{p, "default"}
	case "source":
		p := newAppliedPolicyViewSource(res)
		vres = &appliedpolicyviews.AppliedPolicy{p, "source"}
	case "link":
		p := newAppliedPolicyViewLink(res)
		vres = &appliedpolicyviews.AppliedPolicy{p, "link"}
	}
	return vres
}

// NewAppliedPolicyStatus initializes result type AppliedPolicyStatus from
// viewed result type AppliedPolicyStatus.
func NewAppliedPolicyStatus(vres *appliedpolicyviews.AppliedPolicyStatus) *AppliedPolicyStatus {
	var res *AppliedPolicyStatus
	switch vres.View {
	case "default", "":
		res = newAppliedPolicyStatus(vres.Projected)
	}
	return res
}

// NewViewedAppliedPolicyStatus initializes viewed result type
// AppliedPolicyStatus from result type AppliedPolicyStatus using the given
// view.
func NewViewedAppliedPolicyStatus(res *AppliedPolicyStatus, view string) *appliedpolicyviews.AppliedPolicyStatus {
	var vres *appliedpolicyviews.AppliedPolicyStatus
	switch view {
	case "default", "":
		p := newAppliedPolicyStatusView(res)
		vres = &appliedpolicyviews.AppliedPolicyStatus{p, "default"}
	}
	return vres
}

// NewAppliedPolicyLog initializes result type AppliedPolicyLog from viewed
// result type AppliedPolicyLog.
func NewAppliedPolicyLog(vres *appliedpolicyviews.AppliedPolicyLog) *AppliedPolicyLog {
	var res *AppliedPolicyLog
	switch vres.View {
	case "default", "":
		res = newAppliedPolicyLog(vres.Projected)
	}
	return res
}

// NewViewedAppliedPolicyLog initializes viewed result type AppliedPolicyLog
// from result type AppliedPolicyLog using the given view.
func NewViewedAppliedPolicyLog(res *AppliedPolicyLog, view string) *appliedpolicyviews.AppliedPolicyLog {
	var vres *appliedpolicyviews.AppliedPolicyLog
	switch view {
	case "default", "":
		p := newAppliedPolicyLogView(res)
		vres = &appliedpolicyviews.AppliedPolicyLog{p, "default"}
	}
	return vres
}

// NewAppliedPolicyList initializes result type AppliedPolicyList from viewed
// result type AppliedPolicyList.
func NewAppliedPolicyList(vres *appliedpolicyviews.AppliedPolicyList) *AppliedPolicyList {
	var res *AppliedPolicyList
	switch vres.View {
	case "default", "":
		res = newAppliedPolicyList(vres.Projected)
	case "link":
		res = newAppliedPolicyListLink(vres.Projected)
	}
	return res
}

// NewViewedAppliedPolicyList initializes viewed result type AppliedPolicyList
// from result type AppliedPolicyList using the given view.
func NewViewedAppliedPolicyList(res *AppliedPolicyList, view string) *appliedpolicyviews.AppliedPolicyList {
	var vres *appliedpolicyviews.AppliedPolicyList
	switch view {
	case "default", "":
		p := newAppliedPolicyListView(res)
		vres = &appliedpolicyviews.AppliedPolicyList{p, "default"}
	case "link":
		p := newAppliedPolicyListViewLink(res)
		vres = &appliedpolicyviews.AppliedPolicyList{p, "link"}
	}
	return vres
}

// newAppliedPolicy converts projected type AppliedPolicy to service type
// AppliedPolicy.
func newAppliedPolicy(vres *appliedpolicyviews.AppliedPolicyView) *AppliedPolicy {
	res := &AppliedPolicy{
		Description: vres.Description,
		DocLink:     vres.DocLink,
		CreatedAt:   vres.CreatedAt,
		UpdatedAt:   vres.UpdatedAt,
		Severity:    vres.Severity,
		Category:    vres.Category,
		Frequency:   vres.Frequency,
		DryRun:      vres.DryRun,
		Status:      vres.Status,
		Error:       vres.Error,
		ErroredAt:   vres.ErroredAt,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Project != nil {
		res.Project = unmarshalProjectViewToProject(vres.Project)
	}
	if vres.PublishedTemplate != nil {
		res.PublishedTemplate = unmarshalPublishedTemplateViewToPublishedTemplate(vres.PublishedTemplate)
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = unmarshalUserViewToUser(vres.CreatedBy)
	}
	if vres.Options != nil {
		res.Options = make([]*ConfigurationOption, len(vres.Options))
		for i, val := range vres.Options {
			res.Options[i] = &ConfigurationOption{
				Name:  *val.Name,
				Label: *val.Label,
				Type:  *val.Type,
				Value: *val.Value,
			}
		}
	}
	if vres.PolicyTemplate != nil {
		res.PolicyTemplate = newPolicyTemplateLink(vres.PolicyTemplate)
	}
	return res
}

// newAppliedPolicySource converts projected type AppliedPolicy to service type
// AppliedPolicy.
func newAppliedPolicySource(vres *appliedpolicyviews.AppliedPolicyView) *AppliedPolicy {
	res := &AppliedPolicy{}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Project != nil {
		res.Project = unmarshalProjectViewToProject(vres.Project)
	}
	if vres.PublishedTemplate != nil {
		res.PublishedTemplate = unmarshalPublishedTemplateViewToPublishedTemplate(vres.PublishedTemplate)
	}
	if vres.PolicyTemplate != nil {
		res.PolicyTemplate = newPolicyTemplateSource(vres.PolicyTemplate)
	}
	return res
}

// newAppliedPolicyLink converts projected type AppliedPolicy to service type
// AppliedPolicy.
func newAppliedPolicyLink(vres *appliedpolicyviews.AppliedPolicyView) *AppliedPolicy {
	res := &AppliedPolicy{
		CreatedAt: vres.CreatedAt,
		Frequency: vres.Frequency,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.PublishedTemplate != nil {
		res.PublishedTemplate = unmarshalPublishedTemplateViewToPublishedTemplate(vres.PublishedTemplate)
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = unmarshalUserViewToUser(vres.CreatedBy)
	}
	if vres.PolicyTemplate != nil {
		res.PolicyTemplate = newPolicyTemplateLink(vres.PolicyTemplate)
	}
	return res
}

// newAppliedPolicyView projects result type AppliedPolicy into projected type
// AppliedPolicyView using the "default" view.
func newAppliedPolicyView(res *AppliedPolicy) *appliedpolicyviews.AppliedPolicyView {
	vres := &appliedpolicyviews.AppliedPolicyView{
		ID:          &res.ID,
		Name:        &res.Name,
		Href:        &res.Href,
		Description: res.Description,
		DocLink:     res.DocLink,
		CreatedAt:   res.CreatedAt,
		UpdatedAt:   res.UpdatedAt,
		Severity:    res.Severity,
		Category:    res.Category,
		Frequency:   res.Frequency,
		DryRun:      res.DryRun,
		Status:      res.Status,
		Error:       res.Error,
		ErroredAt:   res.ErroredAt,
		Kind:        &res.Kind,
	}
	if res.Project != nil {
		vres.Project = marshalProjectToProjectView(res.Project)
	}
	if res.PublishedTemplate != nil {
		vres.PublishedTemplate = marshalPublishedTemplateToPublishedTemplateView(res.PublishedTemplate)
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = marshalUserToUserView(res.CreatedBy)
	}
	if res.Options != nil {
		vres.Options = make([]*appliedpolicyviews.ConfigurationOptionView, len(res.Options))
		for i, val := range res.Options {
			vres.Options[i] = &appliedpolicyviews.ConfigurationOptionView{
				Name:  &val.Name,
				Label: &val.Label,
				Type:  &val.Type,
				Value: &val.Value,
			}
		}
	}
	if res.PolicyTemplate != nil {
		vres.PolicyTemplate = newPolicyTemplateViewLink(res.PolicyTemplate)
	}
	return vres
}

// newAppliedPolicyViewSource projects result type AppliedPolicy into projected
// type AppliedPolicyView using the "source" view.
func newAppliedPolicyViewSource(res *AppliedPolicy) *appliedpolicyviews.AppliedPolicyView {
	vres := &appliedpolicyviews.AppliedPolicyView{
		ID:   &res.ID,
		Name: &res.Name,
		Href: &res.Href,
		Kind: &res.Kind,
	}
	if res.Project != nil {
		vres.Project = marshalProjectToProjectView(res.Project)
	}
	if res.PublishedTemplate != nil {
		vres.PublishedTemplate = marshalPublishedTemplateToPublishedTemplateView(res.PublishedTemplate)
	}
	if res.PolicyTemplate != nil {
		vres.PolicyTemplate = newPolicyTemplateViewSource(res.PolicyTemplate)
	}
	return vres
}

// newAppliedPolicyViewLink projects result type AppliedPolicy into projected
// type AppliedPolicyView using the "link" view.
func newAppliedPolicyViewLink(res *AppliedPolicy) *appliedpolicyviews.AppliedPolicyView {
	vres := &appliedpolicyviews.AppliedPolicyView{
		ID:        &res.ID,
		Name:      &res.Name,
		Href:      &res.Href,
		CreatedAt: res.CreatedAt,
		Frequency: res.Frequency,
		Kind:      &res.Kind,
	}
	if res.PublishedTemplate != nil {
		vres.PublishedTemplate = marshalPublishedTemplateToPublishedTemplateView(res.PublishedTemplate)
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = marshalUserToUserView(res.CreatedBy)
	}
	if res.PolicyTemplate != nil {
		vres.PolicyTemplate = newPolicyTemplateViewLink(res.PolicyTemplate)
	}
	return vres
}

// newPolicyTemplate converts projected type PolicyTemplate to service type
// PolicyTemplate.
func newPolicyTemplate(vres *appliedpolicyviews.PolicyTemplateView) *PolicyTemplate {
	res := &PolicyTemplate{
		ProjectID:        vres.ProjectID,
		RsPtVer:          vres.RsPtVer,
		ShortDescription: vres.ShortDescription,
		DocLink:          vres.DocLink,
		Category:         vres.Category,
		CreatedAt:        vres.CreatedAt,
		UpdatedAt:        vres.UpdatedAt,
		Severity:         vres.Severity,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = unmarshalUserViewToUser(vres.CreatedBy)
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = unmarshalUserViewToUser(vres.UpdatedBy)
	}
	if vres.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(vres.RequiredRoles))
		for i, val := range vres.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	return res
}

// newPolicyTemplateExtended converts projected type PolicyTemplate to service
// type PolicyTemplate.
func newPolicyTemplateExtended(vres *appliedpolicyviews.PolicyTemplateView) *PolicyTemplate {
	res := &PolicyTemplate{
		ProjectID:        vres.ProjectID,
		RsPtVer:          vres.RsPtVer,
		ShortDescription: vres.ShortDescription,
		LongDescription:  vres.LongDescription,
		DocLink:          vres.DocLink,
		Category:         vres.Category,
		CreatedAt:        vres.CreatedAt,
		UpdatedAt:        vres.UpdatedAt,
		Severity:         vres.Severity,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = unmarshalUserViewToUser(vres.CreatedBy)
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = unmarshalUserViewToUser(vres.UpdatedBy)
	}
	if vres.Permissions != nil {
		res.Permissions = make(map[string]*Permission, len(vres.Permissions))
		for key, val := range vres.Permissions {
			tk := key
			tv := &Permission{
				Name:  *val.Name,
				Label: val.Label,
			}
			tv.Resources = make([]string, len(val.Resources))
			for i, val := range val.Resources {
				tv.Resources[i] = val
			}
			tv.Actions = make([]string, len(val.Actions))
			for i, val := range val.Actions {
				tv.Actions[i] = val
			}
			res.Permissions[tk] = tv
		}
	}
	if vres.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(vres.RequiredRoles))
		for i, val := range vres.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	if vres.Parameters != nil {
		res.Parameters = make(map[string]*Parameter, len(vres.Parameters))
		for key, val := range vres.Parameters {
			tk := key
			tv := &Parameter{
				Name:                  *val.Name,
				Type:                  *val.Type,
				Label:                 *val.Label,
				Index:                 *val.Index,
				Category:              val.Category,
				Description:           val.Description,
				MinLength:             val.MinLength,
				MaxLength:             val.MaxLength,
				MinValue:              val.MinValue,
				MaxValue:              val.MaxValue,
				ConstraintDescription: val.ConstraintDescription,
			}
			if val.Default != nil {
				tv.Default = *val.Default
			}
			if val.NoEcho != nil {
				tv.NoEcho = *val.NoEcho
			}
			if val.NoEcho == nil {
				tv.NoEcho = false
			}
			if val.AllowedValues != nil {
				tv.AllowedValues = make([]interface{}, len(val.AllowedValues))
				for i, val := range val.AllowedValues {
					tv.AllowedValues[i] = val
				}
			}
			if val.AllowedPattern != nil {
				tv.AllowedPattern = unmarshalRegexpViewToRegexp(val.AllowedPattern)
			}
			res.Parameters[tk] = tv
		}
	}
	return res
}

// newPolicyTemplateSource converts projected type PolicyTemplate to service
// type PolicyTemplate.
func newPolicyTemplateSource(vres *appliedpolicyviews.PolicyTemplateView) *PolicyTemplate {
	res := &PolicyTemplate{
		Filename: vres.Filename,
		Source:   vres.Source,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	return res
}

// newPolicyTemplateLink converts projected type PolicyTemplate to service type
// PolicyTemplate.
func newPolicyTemplateLink(vres *appliedpolicyviews.PolicyTemplateView) *PolicyTemplate {
	res := &PolicyTemplate{
		UpdatedAt: vres.UpdatedAt,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = unmarshalUserViewToUser(vres.UpdatedBy)
	}
	return res
}

// newPolicyTemplateView projects result type PolicyTemplate into projected
// type PolicyTemplateView using the "default" view.
func newPolicyTemplateView(res *PolicyTemplate) *appliedpolicyviews.PolicyTemplateView {
	vres := &appliedpolicyviews.PolicyTemplateView{
		ID:               &res.ID,
		Name:             &res.Name,
		ProjectID:        res.ProjectID,
		RsPtVer:          res.RsPtVer,
		ShortDescription: res.ShortDescription,
		DocLink:          res.DocLink,
		Href:             &res.Href,
		Fingerprint:      &res.Fingerprint,
		Category:         res.Category,
		CreatedAt:        res.CreatedAt,
		UpdatedAt:        res.UpdatedAt,
		Severity:         res.Severity,
		Kind:             &res.Kind,
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = marshalUserToUserView(res.CreatedBy)
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = marshalUserToUserView(res.UpdatedBy)
	}
	if res.RequiredRoles != nil {
		vres.RequiredRoles = make([]string, len(res.RequiredRoles))
		for i, val := range res.RequiredRoles {
			vres.RequiredRoles[i] = val
		}
	}
	return vres
}

// newPolicyTemplateViewExtended projects result type PolicyTemplate into
// projected type PolicyTemplateView using the "extended" view.
func newPolicyTemplateViewExtended(res *PolicyTemplate) *appliedpolicyviews.PolicyTemplateView {
	vres := &appliedpolicyviews.PolicyTemplateView{
		ID:               &res.ID,
		Name:             &res.Name,
		ProjectID:        res.ProjectID,
		RsPtVer:          res.RsPtVer,
		ShortDescription: res.ShortDescription,
		LongDescription:  res.LongDescription,
		DocLink:          res.DocLink,
		Href:             &res.Href,
		Fingerprint:      &res.Fingerprint,
		Category:         res.Category,
		CreatedAt:        res.CreatedAt,
		UpdatedAt:        res.UpdatedAt,
		Severity:         res.Severity,
		Kind:             &res.Kind,
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = marshalUserToUserView(res.CreatedBy)
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = marshalUserToUserView(res.UpdatedBy)
	}
	if res.Permissions != nil {
		vres.Permissions = make(map[string]*appliedpolicyviews.PermissionView, len(res.Permissions))
		for key, val := range res.Permissions {
			tk := key
			tv := &appliedpolicyviews.PermissionView{
				Name:  &val.Name,
				Label: val.Label,
			}
			if val.Resources != nil {
				tv.Resources = make([]string, len(val.Resources))
				for i, val := range val.Resources {
					tv.Resources[i] = val
				}
			}
			if val.Actions != nil {
				tv.Actions = make([]string, len(val.Actions))
				for i, val := range val.Actions {
					tv.Actions[i] = val
				}
			}
			vres.Permissions[tk] = tv
		}
	}
	if res.RequiredRoles != nil {
		vres.RequiredRoles = make([]string, len(res.RequiredRoles))
		for i, val := range res.RequiredRoles {
			vres.RequiredRoles[i] = val
		}
	}
	if res.Parameters != nil {
		vres.Parameters = make(map[string]*appliedpolicyviews.ParameterView, len(res.Parameters))
		for key, val := range res.Parameters {
			tk := key
			tv := &appliedpolicyviews.ParameterView{
				Name:                  &val.Name,
				Type:                  &val.Type,
				Label:                 &val.Label,
				Index:                 &val.Index,
				Category:              val.Category,
				Description:           val.Description,
				Default:               &val.Default,
				NoEcho:                &val.NoEcho,
				MinLength:             val.MinLength,
				MaxLength:             val.MaxLength,
				MinValue:              val.MinValue,
				MaxValue:              val.MaxValue,
				ConstraintDescription: val.ConstraintDescription,
			}
			if val.AllowedValues != nil {
				tv.AllowedValues = make([]interface{}, len(val.AllowedValues))
				for i, val := range val.AllowedValues {
					tv.AllowedValues[i] = val
				}
			}
			if val.AllowedPattern != nil {
				tv.AllowedPattern = marshalRegexpToRegexpView(val.AllowedPattern)
			}
			vres.Parameters[tk] = tv
		}
	}
	return vres
}

// newPolicyTemplateViewSource projects result type PolicyTemplate into
// projected type PolicyTemplateView using the "source" view.
func newPolicyTemplateViewSource(res *PolicyTemplate) *appliedpolicyviews.PolicyTemplateView {
	vres := &appliedpolicyviews.PolicyTemplateView{
		ID:          &res.ID,
		Name:        &res.Name,
		Href:        &res.Href,
		Filename:    res.Filename,
		Source:      res.Source,
		Fingerprint: &res.Fingerprint,
		Kind:        &res.Kind,
	}
	return vres
}

// newPolicyTemplateViewLink projects result type PolicyTemplate into projected
// type PolicyTemplateView using the "link" view.
func newPolicyTemplateViewLink(res *PolicyTemplate) *appliedpolicyviews.PolicyTemplateView {
	vres := &appliedpolicyviews.PolicyTemplateView{
		ID:          &res.ID,
		Name:        &res.Name,
		Href:        &res.Href,
		Fingerprint: &res.Fingerprint,
		UpdatedAt:   res.UpdatedAt,
		Kind:        &res.Kind,
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = marshalUserToUserView(res.UpdatedBy)
	}
	return vres
}

// newPublishedTemplate converts projected type PublishedTemplate to service
// type PublishedTemplate.
func newPublishedTemplate(vres *appliedpolicyviews.PublishedTemplateView) *PublishedTemplate {
	res := &PublishedTemplate{
		OrgID:                     vres.OrgID,
		ProjectID:                 vres.ProjectID,
		PolicyTemplateID:          vres.PolicyTemplateID,
		PolicyTemplateURL:         vres.PolicyTemplateURL,
		PolicyTemplateFingerprint: vres.PolicyTemplateFingerprint,
		RsPtVer:                   vres.RsPtVer,
		ShortDescription:          vres.ShortDescription,
		DocLink:                   vres.DocLink,
		Category:                  vres.Category,
		CreatedAt:                 vres.CreatedAt,
		UpdatedAt:                 vres.UpdatedAt,
		HiddenAt:                  vres.HiddenAt,
		Severity:                  vres.Severity,
		BuiltIn:                   vres.BuiltIn,
		Hidden:                    vres.Hidden,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = unmarshalUserViewToUser(vres.CreatedBy)
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = unmarshalUserViewToUser(vres.UpdatedBy)
	}
	if vres.HiddenBy != nil {
		res.HiddenBy = unmarshalUserViewToUser(vres.HiddenBy)
	}
	if vres.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(vres.RequiredRoles))
		for i, val := range vres.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	return res
}

// newPublishedTemplateExtended converts projected type PublishedTemplate to
// service type PublishedTemplate.
func newPublishedTemplateExtended(vres *appliedpolicyviews.PublishedTemplateView) *PublishedTemplate {
	res := &PublishedTemplate{
		OrgID:                     vres.OrgID,
		ProjectID:                 vres.ProjectID,
		PolicyTemplateID:          vres.PolicyTemplateID,
		PolicyTemplateURL:         vres.PolicyTemplateURL,
		PolicyTemplateFingerprint: vres.PolicyTemplateFingerprint,
		RsPtVer:                   vres.RsPtVer,
		ShortDescription:          vres.ShortDescription,
		LongDescription:           vres.LongDescription,
		DocLink:                   vres.DocLink,
		Category:                  vres.Category,
		CreatedAt:                 vres.CreatedAt,
		UpdatedAt:                 vres.UpdatedAt,
		HiddenAt:                  vres.HiddenAt,
		Severity:                  vres.Severity,
		BuiltIn:                   vres.BuiltIn,
		Hidden:                    vres.Hidden,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Info != nil {
		res.Info = make(map[string]string, len(vres.Info))
		for key, val := range vres.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if vres.CreatedBy != nil {
		res.CreatedBy = unmarshalUserViewToUser(vres.CreatedBy)
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = unmarshalUserViewToUser(vres.UpdatedBy)
	}
	if vres.HiddenBy != nil {
		res.HiddenBy = unmarshalUserViewToUser(vres.HiddenBy)
	}
	if vres.Permissions != nil {
		res.Permissions = make(map[string]*Permission, len(vres.Permissions))
		for key, val := range vres.Permissions {
			tk := key
			tv := &Permission{
				Name:  *val.Name,
				Label: val.Label,
			}
			tv.Resources = make([]string, len(val.Resources))
			for i, val := range val.Resources {
				tv.Resources[i] = val
			}
			tv.Actions = make([]string, len(val.Actions))
			for i, val := range val.Actions {
				tv.Actions[i] = val
			}
			res.Permissions[tk] = tv
		}
	}
	if vres.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(vres.RequiredRoles))
		for i, val := range vres.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	if vres.Parameters != nil {
		res.Parameters = make(map[string]*Parameter, len(vres.Parameters))
		for key, val := range vres.Parameters {
			tk := key
			tv := &Parameter{
				Name:                  *val.Name,
				Type:                  *val.Type,
				Label:                 *val.Label,
				Index:                 *val.Index,
				Category:              val.Category,
				Description:           val.Description,
				MinLength:             val.MinLength,
				MaxLength:             val.MaxLength,
				MinValue:              val.MinValue,
				MaxValue:              val.MaxValue,
				ConstraintDescription: val.ConstraintDescription,
			}
			if val.Default != nil {
				tv.Default = *val.Default
			}
			if val.NoEcho != nil {
				tv.NoEcho = *val.NoEcho
			}
			if val.NoEcho == nil {
				tv.NoEcho = false
			}
			if val.AllowedValues != nil {
				tv.AllowedValues = make([]interface{}, len(val.AllowedValues))
				for i, val := range val.AllowedValues {
					tv.AllowedValues[i] = val
				}
			}
			if val.AllowedPattern != nil {
				tv.AllowedPattern = unmarshalRegexpViewToRegexp(val.AllowedPattern)
			}
			res.Parameters[tk] = tv
		}
	}
	return res
}

// newPublishedTemplateSource converts projected type PublishedTemplate to
// service type PublishedTemplate.
func newPublishedTemplateSource(vres *appliedpolicyviews.PublishedTemplateView) *PublishedTemplate {
	res := &PublishedTemplate{
		Filename: vres.Filename,
		Source:   vres.Source,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	return res
}

// newPublishedTemplateLink converts projected type PublishedTemplate to
// service type PublishedTemplate.
func newPublishedTemplateLink(vres *appliedpolicyviews.PublishedTemplateView) *PublishedTemplate {
	res := &PublishedTemplate{
		UpdatedAt: vres.UpdatedAt,
		BuiltIn:   vres.BuiltIn,
	}
	if vres.ID != nil {
		res.ID = *vres.ID
	}
	if vres.Name != nil {
		res.Name = *vres.Name
	}
	if vres.Href != nil {
		res.Href = *vres.Href
	}
	if vres.Fingerprint != nil {
		res.Fingerprint = *vres.Fingerprint
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.UpdatedBy != nil {
		res.UpdatedBy = unmarshalUserViewToUser(vres.UpdatedBy)
	}
	return res
}

// newPublishedTemplateView projects result type PublishedTemplate into
// projected type PublishedTemplateView using the "default" view.
func newPublishedTemplateView(res *PublishedTemplate) *appliedpolicyviews.PublishedTemplateView {
	vres := &appliedpolicyviews.PublishedTemplateView{
		ID:                        &res.ID,
		Name:                      &res.Name,
		OrgID:                     res.OrgID,
		ProjectID:                 res.ProjectID,
		PolicyTemplateID:          res.PolicyTemplateID,
		PolicyTemplateURL:         res.PolicyTemplateURL,
		PolicyTemplateFingerprint: res.PolicyTemplateFingerprint,
		RsPtVer:                   res.RsPtVer,
		ShortDescription:          res.ShortDescription,
		DocLink:                   res.DocLink,
		Href:                      &res.Href,
		Fingerprint:               &res.Fingerprint,
		Category:                  res.Category,
		CreatedAt:                 res.CreatedAt,
		UpdatedAt:                 res.UpdatedAt,
		Severity:                  res.Severity,
		BuiltIn:                   res.BuiltIn,
		Hidden:                    res.Hidden,
		HiddenAt:                  res.HiddenAt,
		Kind:                      &res.Kind,
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = marshalUserToUserView(res.CreatedBy)
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = marshalUserToUserView(res.UpdatedBy)
	}
	if res.RequiredRoles != nil {
		vres.RequiredRoles = make([]string, len(res.RequiredRoles))
		for i, val := range res.RequiredRoles {
			vres.RequiredRoles[i] = val
		}
	}
	if res.HiddenBy != nil {
		vres.HiddenBy = marshalUserToUserView(res.HiddenBy)
	}
	return vres
}

// newPublishedTemplateViewExtended projects result type PublishedTemplate into
// projected type PublishedTemplateView using the "extended" view.
func newPublishedTemplateViewExtended(res *PublishedTemplate) *appliedpolicyviews.PublishedTemplateView {
	vres := &appliedpolicyviews.PublishedTemplateView{
		ID:                        &res.ID,
		Name:                      &res.Name,
		OrgID:                     res.OrgID,
		ProjectID:                 res.ProjectID,
		PolicyTemplateID:          res.PolicyTemplateID,
		PolicyTemplateURL:         res.PolicyTemplateURL,
		PolicyTemplateFingerprint: res.PolicyTemplateFingerprint,
		RsPtVer:                   res.RsPtVer,
		ShortDescription:          res.ShortDescription,
		LongDescription:           res.LongDescription,
		DocLink:                   res.DocLink,
		Href:                      &res.Href,
		Fingerprint:               &res.Fingerprint,
		Category:                  res.Category,
		CreatedAt:                 res.CreatedAt,
		UpdatedAt:                 res.UpdatedAt,
		Severity:                  res.Severity,
		BuiltIn:                   res.BuiltIn,
		Hidden:                    res.Hidden,
		HiddenAt:                  res.HiddenAt,
		Kind:                      &res.Kind,
	}
	if res.Info != nil {
		vres.Info = make(map[string]string, len(res.Info))
		for key, val := range res.Info {
			tk := key
			tv := val
			vres.Info[tk] = tv
		}
	}
	if res.CreatedBy != nil {
		vres.CreatedBy = marshalUserToUserView(res.CreatedBy)
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = marshalUserToUserView(res.UpdatedBy)
	}
	if res.Permissions != nil {
		vres.Permissions = make(map[string]*appliedpolicyviews.PermissionView, len(res.Permissions))
		for key, val := range res.Permissions {
			tk := key
			tv := &appliedpolicyviews.PermissionView{
				Name:  &val.Name,
				Label: val.Label,
			}
			if val.Resources != nil {
				tv.Resources = make([]string, len(val.Resources))
				for i, val := range val.Resources {
					tv.Resources[i] = val
				}
			}
			if val.Actions != nil {
				tv.Actions = make([]string, len(val.Actions))
				for i, val := range val.Actions {
					tv.Actions[i] = val
				}
			}
			vres.Permissions[tk] = tv
		}
	}
	if res.RequiredRoles != nil {
		vres.RequiredRoles = make([]string, len(res.RequiredRoles))
		for i, val := range res.RequiredRoles {
			vres.RequiredRoles[i] = val
		}
	}
	if res.Parameters != nil {
		vres.Parameters = make(map[string]*appliedpolicyviews.ParameterView, len(res.Parameters))
		for key, val := range res.Parameters {
			tk := key
			tv := &appliedpolicyviews.ParameterView{
				Name:                  &val.Name,
				Type:                  &val.Type,
				Label:                 &val.Label,
				Index:                 &val.Index,
				Category:              val.Category,
				Description:           val.Description,
				Default:               &val.Default,
				NoEcho:                &val.NoEcho,
				MinLength:             val.MinLength,
				MaxLength:             val.MaxLength,
				MinValue:              val.MinValue,
				MaxValue:              val.MaxValue,
				ConstraintDescription: val.ConstraintDescription,
			}
			if val.AllowedValues != nil {
				tv.AllowedValues = make([]interface{}, len(val.AllowedValues))
				for i, val := range val.AllowedValues {
					tv.AllowedValues[i] = val
				}
			}
			if val.AllowedPattern != nil {
				tv.AllowedPattern = marshalRegexpToRegexpView(val.AllowedPattern)
			}
			vres.Parameters[tk] = tv
		}
	}
	if res.HiddenBy != nil {
		vres.HiddenBy = marshalUserToUserView(res.HiddenBy)
	}
	return vres
}

// newPublishedTemplateViewSource projects result type PublishedTemplate into
// projected type PublishedTemplateView using the "source" view.
func newPublishedTemplateViewSource(res *PublishedTemplate) *appliedpolicyviews.PublishedTemplateView {
	vres := &appliedpolicyviews.PublishedTemplateView{
		ID:          &res.ID,
		Name:        &res.Name,
		Href:        &res.Href,
		Filename:    res.Filename,
		Source:      res.Source,
		Fingerprint: &res.Fingerprint,
		Kind:        &res.Kind,
	}
	return vres
}

// newPublishedTemplateViewLink projects result type PublishedTemplate into
// projected type PublishedTemplateView using the "link" view.
func newPublishedTemplateViewLink(res *PublishedTemplate) *appliedpolicyviews.PublishedTemplateView {
	vres := &appliedpolicyviews.PublishedTemplateView{
		ID:          &res.ID,
		Name:        &res.Name,
		Href:        &res.Href,
		Fingerprint: &res.Fingerprint,
		UpdatedAt:   res.UpdatedAt,
		BuiltIn:     res.BuiltIn,
		Kind:        &res.Kind,
	}
	if res.UpdatedBy != nil {
		vres.UpdatedBy = marshalUserToUserView(res.UpdatedBy)
	}
	return vres
}

// newAppliedPolicyStatus converts projected type AppliedPolicyStatus to
// service type AppliedPolicyStatus.
func newAppliedPolicyStatus(vres *appliedpolicyviews.AppliedPolicyStatusView) *AppliedPolicyStatus {
	res := &AppliedPolicyStatus{
		LastEvaluationStart:  vres.LastEvaluationStart,
		LastEvaluationFinish: vres.LastEvaluationFinish,
		NextEvaluationStart:  vres.NextEvaluationStart,
		EvaluationError:      vres.EvaluationError,
		EvaluationErroredAt:  vres.EvaluationErroredAt,
	}
	return res
}

// newAppliedPolicyStatusView projects result type AppliedPolicyStatus into
// projected type AppliedPolicyStatusView using the "default" view.
func newAppliedPolicyStatusView(res *AppliedPolicyStatus) *appliedpolicyviews.AppliedPolicyStatusView {
	vres := &appliedpolicyviews.AppliedPolicyStatusView{
		LastEvaluationStart:  res.LastEvaluationStart,
		LastEvaluationFinish: res.LastEvaluationFinish,
		NextEvaluationStart:  res.NextEvaluationStart,
		EvaluationError:      res.EvaluationError,
		EvaluationErroredAt:  res.EvaluationErroredAt,
	}
	return vres
}

// newAppliedPolicyLog converts projected type AppliedPolicyLog to service type
// AppliedPolicyLog.
func newAppliedPolicyLog(vres *appliedpolicyviews.AppliedPolicyLogView) *AppliedPolicyLog {
	res := &AppliedPolicyLog{
		ResponseBody: vres.ResponseBody,
		LastModified: vres.LastModified,
		Etag:         vres.Etag,
	}
	return res
}

// newAppliedPolicyLogView projects result type AppliedPolicyLog into projected
// type AppliedPolicyLogView using the "default" view.
func newAppliedPolicyLogView(res *AppliedPolicyLog) *appliedpolicyviews.AppliedPolicyLogView {
	vres := &appliedpolicyviews.AppliedPolicyLogView{
		ResponseBody: res.ResponseBody,
		LastModified: res.LastModified,
		Etag:         res.Etag,
	}
	return vres
}

// newAppliedPolicyList converts projected type AppliedPolicyList to service
// type AppliedPolicyList.
func newAppliedPolicyList(vres *appliedpolicyviews.AppliedPolicyListView) *AppliedPolicyList {
	res := &AppliedPolicyList{
		Count:       vres.Count,
		NotModified: vres.NotModified,
	}
	if vres.Etag != nil {
		res.Etag = *vres.Etag
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Items != nil {
		res.Items = newAppliedPolicyCollection(vres.Items)
	}
	return res
}

// newAppliedPolicyListLink converts projected type AppliedPolicyList to
// service type AppliedPolicyList.
func newAppliedPolicyListLink(vres *appliedpolicyviews.AppliedPolicyListView) *AppliedPolicyList {
	res := &AppliedPolicyList{
		Count:       vres.Count,
		NotModified: vres.NotModified,
	}
	if vres.Etag != nil {
		res.Etag = *vres.Etag
	}
	if vres.Kind != nil {
		res.Kind = *vres.Kind
	}
	if vres.Items != nil {
		res.Items = newAppliedPolicyCollectionLink(vres.Items)
	}
	return res
}

// newAppliedPolicyListView projects result type AppliedPolicyList into
// projected type AppliedPolicyListView using the "default" view.
func newAppliedPolicyListView(res *AppliedPolicyList) *appliedpolicyviews.AppliedPolicyListView {
	vres := &appliedpolicyviews.AppliedPolicyListView{
		Count:       res.Count,
		Etag:        &res.Etag,
		NotModified: res.NotModified,
		Kind:        &res.Kind,
	}
	if res.Items != nil {
		vres.Items = newAppliedPolicyCollectionView(res.Items)
	}
	return vres
}

// newAppliedPolicyListViewLink projects result type AppliedPolicyList into
// projected type AppliedPolicyListView using the "link" view.
func newAppliedPolicyListViewLink(res *AppliedPolicyList) *appliedpolicyviews.AppliedPolicyListView {
	vres := &appliedpolicyviews.AppliedPolicyListView{
		Count:       res.Count,
		Etag:        &res.Etag,
		NotModified: res.NotModified,
		Kind:        &res.Kind,
	}
	if res.Items != nil {
		vres.Items = newAppliedPolicyCollectionViewLink(res.Items)
	}
	return vres
}

// newAppliedPolicyCollection converts projected type AppliedPolicyCollection
// to service type AppliedPolicyCollection.
func newAppliedPolicyCollection(vres appliedpolicyviews.AppliedPolicyCollectionView) AppliedPolicyCollection {
	res := make(AppliedPolicyCollection, len(vres))
	for i, n := range vres {
		res[i] = newAppliedPolicy(n)
	}
	return res
}

// newAppliedPolicyCollectionSource converts projected type
// AppliedPolicyCollection to service type AppliedPolicyCollection.
func newAppliedPolicyCollectionSource(vres appliedpolicyviews.AppliedPolicyCollectionView) AppliedPolicyCollection {
	res := make(AppliedPolicyCollection, len(vres))
	for i, n := range vres {
		res[i] = newAppliedPolicySource(n)
	}
	return res
}

// newAppliedPolicyCollectionLink converts projected type
// AppliedPolicyCollection to service type AppliedPolicyCollection.
func newAppliedPolicyCollectionLink(vres appliedpolicyviews.AppliedPolicyCollectionView) AppliedPolicyCollection {
	res := make(AppliedPolicyCollection, len(vres))
	for i, n := range vres {
		res[i] = newAppliedPolicyLink(n)
	}
	return res
}

// newAppliedPolicyCollectionView projects result type AppliedPolicyCollection
// into projected type AppliedPolicyCollectionView using the "default" view.
func newAppliedPolicyCollectionView(res AppliedPolicyCollection) appliedpolicyviews.AppliedPolicyCollectionView {
	vres := make(appliedpolicyviews.AppliedPolicyCollectionView, len(res))
	for i, n := range res {
		vres[i] = newAppliedPolicyView(n)
	}
	return vres
}

// newAppliedPolicyCollectionViewSource projects result type
// AppliedPolicyCollection into projected type AppliedPolicyCollectionView
// using the "source" view.
func newAppliedPolicyCollectionViewSource(res AppliedPolicyCollection) appliedpolicyviews.AppliedPolicyCollectionView {
	vres := make(appliedpolicyviews.AppliedPolicyCollectionView, len(res))
	for i, n := range res {
		vres[i] = newAppliedPolicyViewSource(n)
	}
	return vres
}

// newAppliedPolicyCollectionViewLink projects result type
// AppliedPolicyCollection into projected type AppliedPolicyCollectionView
// using the "link" view.
func newAppliedPolicyCollectionViewLink(res AppliedPolicyCollection) appliedpolicyviews.AppliedPolicyCollectionView {
	vres := make(appliedpolicyviews.AppliedPolicyCollectionView, len(res))
	for i, n := range res {
		vres[i] = newAppliedPolicyViewLink(n)
	}
	return vres
}

// unmarshalProjectViewToProject builds a value of type *Project from a value
// of type *appliedpolicyviews.ProjectView.
func unmarshalProjectViewToProject(v *appliedpolicyviews.ProjectView) *Project {
	if v == nil {
		return nil
	}
	res := &Project{
		ID:      *v.ID,
		Name:    *v.Name,
		OrgID:   *v.OrgID,
		OrgName: *v.OrgName,
	}

	return res
}

// unmarshalPublishedTemplateViewToPublishedTemplate builds a value of type
// *PublishedTemplate from a value of type
// *appliedpolicyviews.PublishedTemplateView.
func unmarshalPublishedTemplateViewToPublishedTemplate(v *appliedpolicyviews.PublishedTemplateView) *PublishedTemplate {
	if v == nil {
		return nil
	}
	res := &PublishedTemplate{
		ID:                        *v.ID,
		Name:                      *v.Name,
		OrgID:                     v.OrgID,
		ProjectID:                 v.ProjectID,
		PolicyTemplateID:          v.PolicyTemplateID,
		PolicyTemplateURL:         v.PolicyTemplateURL,
		PolicyTemplateFingerprint: v.PolicyTemplateFingerprint,
		RsPtVer:                   v.RsPtVer,
		ShortDescription:          v.ShortDescription,
		LongDescription:           v.LongDescription,
		DocLink:                   v.DocLink,
		Href:                      *v.Href,
		Filename:                  v.Filename,
		Source:                    v.Source,
		Fingerprint:               *v.Fingerprint,
		Category:                  v.Category,
		CreatedAt:                 v.CreatedAt,
		UpdatedAt:                 v.UpdatedAt,
		Severity:                  v.Severity,
		BuiltIn:                   v.BuiltIn,
		Hidden:                    v.Hidden,
		HiddenAt:                  v.HiddenAt,
		Kind:                      *v.Kind,
	}
	if v.Info != nil {
		res.Info = make(map[string]string, len(v.Info))
		for key, val := range v.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if v.CreatedBy != nil {
		res.CreatedBy = unmarshalUserViewToUser(v.CreatedBy)
	}
	if v.UpdatedBy != nil {
		res.UpdatedBy = unmarshalUserViewToUser(v.UpdatedBy)
	}
	if v.Permissions != nil {
		res.Permissions = make(map[string]*Permission, len(v.Permissions))
		for key, val := range v.Permissions {
			tk := key
			tv := &Permission{
				Name:  *val.Name,
				Label: val.Label,
			}
			tv.Resources = make([]string, len(val.Resources))
			for i, val := range val.Resources {
				tv.Resources[i] = val
			}
			tv.Actions = make([]string, len(val.Actions))
			for i, val := range val.Actions {
				tv.Actions[i] = val
			}
			res.Permissions[tk] = tv
		}
	}
	if v.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(v.RequiredRoles))
		for i, val := range v.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	if v.Parameters != nil {
		res.Parameters = make(map[string]*Parameter, len(v.Parameters))
		for key, val := range v.Parameters {
			tk := key
			tv := &Parameter{
				Name:                  *val.Name,
				Type:                  *val.Type,
				Label:                 *val.Label,
				Index:                 *val.Index,
				Category:              val.Category,
				Description:           val.Description,
				MinLength:             val.MinLength,
				MaxLength:             val.MaxLength,
				MinValue:              val.MinValue,
				MaxValue:              val.MaxValue,
				ConstraintDescription: val.ConstraintDescription,
			}
			if val.Default != nil {
				tv.Default = *val.Default
			}
			if val.NoEcho != nil {
				tv.NoEcho = *val.NoEcho
			}
			if val.NoEcho == nil {
				tv.NoEcho = false
			}
			if val.AllowedValues != nil {
				tv.AllowedValues = make([]interface{}, len(val.AllowedValues))
				for i, val := range val.AllowedValues {
					tv.AllowedValues[i] = val
				}
			}
			if val.AllowedPattern != nil {
				tv.AllowedPattern = unmarshalRegexpViewToRegexp(val.AllowedPattern)
			}
			res.Parameters[tk] = tv
		}
	}
	if v.HiddenBy != nil {
		res.HiddenBy = unmarshalUserViewToUser(v.HiddenBy)
	}

	return res
}

// unmarshalUserViewToUser builds a value of type *User from a value of type
// *appliedpolicyviews.UserView.
func unmarshalUserViewToUser(v *appliedpolicyviews.UserView) *User {
	if v == nil {
		return nil
	}
	res := &User{
		ID:    *v.ID,
		Email: *v.Email,
		Name:  *v.Name,
	}

	return res
}

// unmarshalRegexpViewToRegexp builds a value of type *Regexp from a value of
// type *appliedpolicyviews.RegexpView.
func unmarshalRegexpViewToRegexp(v *appliedpolicyviews.RegexpView) *Regexp {
	if v == nil {
		return nil
	}
	res := &Regexp{
		Pattern: *v.Pattern,
		Options: v.Options,
	}

	return res
}

// marshalProjectToProjectView builds a value of type
// *appliedpolicyviews.ProjectView from a value of type *Project.
func marshalProjectToProjectView(v *Project) *appliedpolicyviews.ProjectView {
	if v == nil {
		return nil
	}
	res := &appliedpolicyviews.ProjectView{
		ID:      &v.ID,
		Name:    &v.Name,
		OrgID:   &v.OrgID,
		OrgName: &v.OrgName,
	}

	return res
}

// marshalPublishedTemplateToPublishedTemplateView builds a value of type
// *appliedpolicyviews.PublishedTemplateView from a value of type
// *PublishedTemplate.
func marshalPublishedTemplateToPublishedTemplateView(v *PublishedTemplate) *appliedpolicyviews.PublishedTemplateView {
	if v == nil {
		return nil
	}
	res := &appliedpolicyviews.PublishedTemplateView{
		ID:                        &v.ID,
		Name:                      &v.Name,
		OrgID:                     v.OrgID,
		ProjectID:                 v.ProjectID,
		PolicyTemplateID:          v.PolicyTemplateID,
		PolicyTemplateURL:         v.PolicyTemplateURL,
		PolicyTemplateFingerprint: v.PolicyTemplateFingerprint,
		RsPtVer:                   v.RsPtVer,
		ShortDescription:          v.ShortDescription,
		LongDescription:           v.LongDescription,
		DocLink:                   v.DocLink,
		Href:                      &v.Href,
		Filename:                  v.Filename,
		Source:                    v.Source,
		Fingerprint:               &v.Fingerprint,
		Category:                  v.Category,
		CreatedAt:                 v.CreatedAt,
		UpdatedAt:                 v.UpdatedAt,
		Severity:                  v.Severity,
		BuiltIn:                   v.BuiltIn,
		Hidden:                    v.Hidden,
		HiddenAt:                  v.HiddenAt,
		Kind:                      &v.Kind,
	}
	if v.Info != nil {
		res.Info = make(map[string]string, len(v.Info))
		for key, val := range v.Info {
			tk := key
			tv := val
			res.Info[tk] = tv
		}
	}
	if v.CreatedBy != nil {
		res.CreatedBy = marshalUserToUserView(v.CreatedBy)
	}
	if v.UpdatedBy != nil {
		res.UpdatedBy = marshalUserToUserView(v.UpdatedBy)
	}
	if v.Permissions != nil {
		res.Permissions = make(map[string]*appliedpolicyviews.PermissionView, len(v.Permissions))
		for key, val := range v.Permissions {
			tk := key
			tv := &appliedpolicyviews.PermissionView{
				Name:  &val.Name,
				Label: val.Label,
			}
			if val.Resources != nil {
				tv.Resources = make([]string, len(val.Resources))
				for i, val := range val.Resources {
					tv.Resources[i] = val
				}
			}
			if val.Actions != nil {
				tv.Actions = make([]string, len(val.Actions))
				for i, val := range val.Actions {
					tv.Actions[i] = val
				}
			}
			res.Permissions[tk] = tv
		}
	}
	if v.RequiredRoles != nil {
		res.RequiredRoles = make([]string, len(v.RequiredRoles))
		for i, val := range v.RequiredRoles {
			res.RequiredRoles[i] = val
		}
	}
	if v.Parameters != nil {
		res.Parameters = make(map[string]*appliedpolicyviews.ParameterView, len(v.Parameters))
		for key, val := range v.Parameters {
			tk := key
			tv := &appliedpolicyviews.ParameterView{
				Name:                  &val.Name,
				Type:                  &val.Type,
				Label:                 &val.Label,
				Index:                 &val.Index,
				Category:              val.Category,
				Description:           val.Description,
				Default:               &val.Default,
				NoEcho:                &val.NoEcho,
				MinLength:             val.MinLength,
				MaxLength:             val.MaxLength,
				MinValue:              val.MinValue,
				MaxValue:              val.MaxValue,
				ConstraintDescription: val.ConstraintDescription,
			}
			if val.AllowedValues != nil {
				tv.AllowedValues = make([]interface{}, len(val.AllowedValues))
				for i, val := range val.AllowedValues {
					tv.AllowedValues[i] = val
				}
			}
			if val.AllowedPattern != nil {
				tv.AllowedPattern = marshalRegexpToRegexpView(val.AllowedPattern)
			}
			res.Parameters[tk] = tv
		}
	}
	if v.HiddenBy != nil {
		res.HiddenBy = marshalUserToUserView(v.HiddenBy)
	}

	return res
}

// marshalUserToUserView builds a value of type *appliedpolicyviews.UserView
// from a value of type *User.
func marshalUserToUserView(v *User) *appliedpolicyviews.UserView {
	if v == nil {
		return nil
	}
	res := &appliedpolicyviews.UserView{
		ID:    &v.ID,
		Email: &v.Email,
		Name:  &v.Name,
	}

	return res
}

// marshalRegexpToRegexpView builds a value of type
// *appliedpolicyviews.RegexpView from a value of type *Regexp.
func marshalRegexpToRegexpView(v *Regexp) *appliedpolicyviews.RegexpView {
	if v == nil {
		return nil
	}
	res := &appliedpolicyviews.RegexpView{
		Pattern: &v.Pattern,
		Options: v.Options,
	}

	return res
}
