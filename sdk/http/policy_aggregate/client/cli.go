// Code generated by goa v3.0.6, DO NOT EDIT.
//
// PolicyAggregate HTTP client CLI support package
//
// Command:
// $ goa gen github.com/rightscale/governance/front_service/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"

	policyaggregate "github.com/rightscale/governance/front_service/gen/policy_aggregate"
	goa "goa.design/goa/v3/pkg"
)

// BuildCreatePayload builds the payload for the PolicyAggregate create
// endpoint from CLI flags.
func BuildCreatePayload(policyAggregateCreateBody string, policyAggregateCreateOrgID string, policyAggregateCreateAPIVersion string, policyAggregateCreateToken string) (*policyaggregate.CreatePayload, error) {
	var err error
	var body CreateRequestBody
	{
		err = json.Unmarshal([]byte(policyAggregateCreateBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, example of valid JSON:\n%s", "'{\n      \"credentials\": {\n         \"Consequatur voluptatibus non perspiciatis sit.\": \"Nulla inventore eum illo laborum distinctio.\",\n         \"Error repellat sapiente minus nam eum.\": \"Voluptatem incidunt enim.\"\n      },\n      \"description\": \"Delete unattached volumes after 24 hours in US-East.\",\n      \"dry_run\": false,\n      \"frequency\": \"daily\",\n      \"name\": \"us_east_unattached_volumes\",\n      \"options\": [\n         {\n            \"name\": \"cloud_vendor\",\n            \"value\": \"AWS\"\n         },\n         {\n            \"name\": \"email_list\",\n            \"value\": [\n               \"person1@domain.com\",\n               \"person2@domain.com\"\n            ]\n         }\n      ],\n      \"skip_approvals\": false,\n      \"template_href\": \"/api/governance/projects/60073/policy_templates/5b06ead5e0dacc007058c784\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("body.template_href", body.TemplateHref, "^/api/governance/orgs/[0-9]+/published_templates/[0-9a-f]+$"))
		if !(body.Frequency == "15 minutes" || body.Frequency == "hourly" || body.Frequency == "daily" || body.Frequency == "weekly" || body.Frequency == "monthly") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.frequency", body.Frequency, []interface{}{"15 minutes", "hourly", "daily", "weekly", "monthly"}))
		}
		for _, e := range body.Options {
			if e != nil {
				if err2 := ValidateConfigurationOptionCreateTypeRequestBody(e); err2 != nil {
					err = goa.MergeErrors(err, err2)
				}
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var orgID uint
	{
		var v uint64
		v, err = strconv.ParseUint(policyAggregateCreateOrgID, 10, 64)
		orgID = uint(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for orgID, must be UINT")
		}
	}
	var apiVersion string
	{
		apiVersion = policyAggregateCreateAPIVersion
	}
	var token *string
	{
		if policyAggregateCreateToken != "" {
			token = &policyAggregateCreateToken
		}
	}
	v := &policyaggregate.CreatePayload{
		Name:          body.Name,
		Description:   body.Description,
		TemplateHref:  body.TemplateHref,
		AllProjects:   body.AllProjects,
		Frequency:     body.Frequency,
		DryRun:        body.DryRun,
		SkipApprovals: body.SkipApprovals,
	}
	if body.ProjectIds != nil {
		v.ProjectIds = make([]uint, len(body.ProjectIds))
		for i, val := range body.ProjectIds {
			v.ProjectIds[i] = val
		}
	}
	if body.Options != nil {
		v.Options = make([]*policyaggregate.ConfigurationOptionCreateType, len(body.Options))
		for i, val := range body.Options {
			v.Options[i] = marshalConfigurationOptionCreateTypeRequestBodyToPolicyaggregateConfigurationOptionCreateType(val)
		}
	}
	if body.Credentials != nil {
		v.Credentials = make(map[string]string, len(body.Credentials))
		for key, val := range body.Credentials {
			tk := key
			tv := val
			v.Credentials[tk] = tv
		}
	}
	v.OrgID = orgID
	v.APIVersion = apiVersion
	v.Token = token
	return v, nil
}

// BuildUpdatePayload builds the payload for the PolicyAggregate update
// endpoint from CLI flags.
func BuildUpdatePayload(policyAggregateUpdateBody string, policyAggregateUpdateOrgID string, policyAggregateUpdatePolicyAggregateID string, policyAggregateUpdateAPIVersion string, policyAggregateUpdateToken string) (*policyaggregate.UpdatePayload, error) {
	var err error
	var body UpdateRequestBody
	{
		err = json.Unmarshal([]byte(policyAggregateUpdateBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, example of valid JSON:\n%s", "'{\n      \"excluded_project_ids\": [\n         60073\n      ],\n      \"project_ids\": [\n         60072\n      ]\n   }'")
		}
	}
	var orgID uint
	{
		var v uint64
		v, err = strconv.ParseUint(policyAggregateUpdateOrgID, 10, 64)
		orgID = uint(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for orgID, must be UINT")
		}
	}
	var policyAggregateID string
	{
		policyAggregateID = policyAggregateUpdatePolicyAggregateID
	}
	var apiVersion string
	{
		apiVersion = policyAggregateUpdateAPIVersion
	}
	var token *string
	{
		if policyAggregateUpdateToken != "" {
			token = &policyAggregateUpdateToken
		}
	}
	v := &policyaggregate.UpdatePayload{}
	if body.ProjectIds != nil {
		v.ProjectIds = make([]uint, len(body.ProjectIds))
		for i, val := range body.ProjectIds {
			v.ProjectIds[i] = val
		}
	}
	if body.ExcludedProjectIds != nil {
		v.ExcludedProjectIds = make([]uint, len(body.ExcludedProjectIds))
		for i, val := range body.ExcludedProjectIds {
			v.ExcludedProjectIds[i] = val
		}
	}
	v.OrgID = orgID
	v.PolicyAggregateID = policyAggregateID
	v.APIVersion = apiVersion
	v.Token = token
	return v, nil
}

// BuildDeletePayload builds the payload for the PolicyAggregate delete
// endpoint from CLI flags.
func BuildDeletePayload(policyAggregateDeleteOrgID string, policyAggregateDeletePolicyAggregateID string, policyAggregateDeleteAPIVersion string, policyAggregateDeleteToken string) (*policyaggregate.DeletePayload, error) {
	var err error
	var orgID uint
	{
		var v uint64
		v, err = strconv.ParseUint(policyAggregateDeleteOrgID, 10, 64)
		orgID = uint(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for orgID, must be UINT")
		}
	}
	var policyAggregateID string
	{
		policyAggregateID = policyAggregateDeletePolicyAggregateID
	}
	var apiVersion string
	{
		apiVersion = policyAggregateDeleteAPIVersion
	}
	var token *string
	{
		if policyAggregateDeleteToken != "" {
			token = &policyAggregateDeleteToken
		}
	}
	payload := &policyaggregate.DeletePayload{
		OrgID:             orgID,
		PolicyAggregateID: policyAggregateID,
		APIVersion:        apiVersion,
		Token:             token,
	}
	return payload, nil
}

// BuildShowPayload builds the payload for the PolicyAggregate show endpoint
// from CLI flags.
func BuildShowPayload(policyAggregateShowOrgID string, policyAggregateShowPolicyAggregateID string, policyAggregateShowView string, policyAggregateShowAPIVersion string, policyAggregateShowToken string) (*policyaggregate.ShowPayload, error) {
	var err error
	var orgID uint
	{
		var v uint64
		v, err = strconv.ParseUint(policyAggregateShowOrgID, 10, 64)
		orgID = uint(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for orgID, must be UINT")
		}
	}
	var policyAggregateID string
	{
		policyAggregateID = policyAggregateShowPolicyAggregateID
	}
	var view *string
	{
		if policyAggregateShowView != "" {
			view = &policyAggregateShowView
		}
	}
	var apiVersion string
	{
		apiVersion = policyAggregateShowAPIVersion
	}
	var token *string
	{
		if policyAggregateShowToken != "" {
			token = &policyAggregateShowToken
		}
	}
	payload := &policyaggregate.ShowPayload{
		OrgID:             orgID,
		PolicyAggregateID: policyAggregateID,
		View:              view,
		APIVersion:        apiVersion,
		Token:             token,
	}
	return payload, nil
}

// BuildShowNonCatalogPayload builds the payload for the PolicyAggregate
// show_non_catalog endpoint from CLI flags.
func BuildShowNonCatalogPayload(policyAggregateShowNonCatalogOrgID string, policyAggregateShowNonCatalogView string, policyAggregateShowNonCatalogAPIVersion string, policyAggregateShowNonCatalogToken string) (*policyaggregate.ShowNonCatalogPayload, error) {
	var err error
	var orgID uint
	{
		var v uint64
		v, err = strconv.ParseUint(policyAggregateShowNonCatalogOrgID, 10, 64)
		orgID = uint(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for orgID, must be UINT")
		}
	}
	var view *string
	{
		if policyAggregateShowNonCatalogView != "" {
			view = &policyAggregateShowNonCatalogView
		}
	}
	var apiVersion string
	{
		apiVersion = policyAggregateShowNonCatalogAPIVersion
	}
	var token *string
	{
		if policyAggregateShowNonCatalogToken != "" {
			token = &policyAggregateShowNonCatalogToken
		}
	}
	payload := &policyaggregate.ShowNonCatalogPayload{
		OrgID:      orgID,
		View:       view,
		APIVersion: apiVersion,
		Token:      token,
	}
	return payload, nil
}

// BuildIndexPayload builds the payload for the PolicyAggregate index endpoint
// from CLI flags.
func BuildIndexPayload(policyAggregateIndexOrgID string, policyAggregateIndexView string, policyAggregateIndexName string, policyAggregateIndexAPIVersion string, policyAggregateIndexEtag string, policyAggregateIndexToken string) (*policyaggregate.IndexPayload, error) {
	var err error
	var orgID uint
	{
		var v uint64
		v, err = strconv.ParseUint(policyAggregateIndexOrgID, 10, 64)
		orgID = uint(v)
		if err != nil {
			return nil, fmt.Errorf("invalid value for orgID, must be UINT")
		}
	}
	var view *string
	{
		if policyAggregateIndexView != "" {
			view = &policyAggregateIndexView
		}
	}
	var name []string
	{
		if policyAggregateIndexName != "" {
			err = json.Unmarshal([]byte(policyAggregateIndexName), &name)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for name, example of valid JSON:\n%s", "'[\n      \"Tag Checker Policy\"\n   ]'")
			}
		}
	}
	var apiVersion string
	{
		apiVersion = policyAggregateIndexAPIVersion
	}
	var etag *string
	{
		if policyAggregateIndexEtag != "" {
			etag = &policyAggregateIndexEtag
		}
	}
	var token *string
	{
		if policyAggregateIndexToken != "" {
			token = &policyAggregateIndexToken
		}
	}
	payload := &policyaggregate.IndexPayload{
		OrgID:      orgID,
		View:       view,
		Name:       name,
		APIVersion: apiVersion,
		Etag:       etag,
		Token:      token,
	}
	return payload, nil
}
